var documenterSearchIndex = {"docs":
[{"location":"#![POMATO-SOUP](https://raw.githubusercontent.com/richard-weinhold/pomato/main/docs/_static/graphics/pomato_logo_small.png)-RedundancyRemoval-for-Fast-Security-Constraint-Optimal-Power-Flow","page":"Introducion","title":"(Image: POMATO SOUP) RedundancyRemoval for Fast Security Constraint Optimal Power Flow","text":"","category":"section"},{"location":"","page":"Introducion","title":"Introducion","text":"(Image: RedundancyRemoval)","category":"page"},{"location":"","page":"Introducion","title":"Introducion","text":"(Image: codecov)","category":"page"},{"location":"#Overview","page":"Introducion","title":"Overview","text":"","category":"section"},{"location":"","page":"Introducion","title":"Introducion","text":"Determining contingency aware dispatch decisions by solving a security-constrained optimal power flow (SCOPF)is challenging for real-world power systems, as the high problem dimensionality often leads to impractical computational requirements. This problem becomes more severe when the SCOPF has to be solved not only for a single instance, but for multiple periods, e.g. in the context of electricity market analyses. The RedundancyRemoval algorithm identifies the minimal set of constraints that exactly define the space of feasible nodal injections for a given network and contingency scenarios. Please see the corresponding publication for further information.","category":"page"},{"location":"#Installation","page":"Introducion","title":"Installation","text":"","category":"section"},{"location":"","page":"Introducion","title":"Introducion","text":"This package is meant to be used in conjunction with the python POMATO model, which embeds its features and installs it automatically. ","category":"page"},{"location":"","page":"Introducion","title":"Introducion","text":"Stand alone usage is possible, however specificity formatted data. ","category":"page"},{"location":"","page":"Introducion","title":"Introducion","text":"Installation can be done directly from git via: ","category":"page"},{"location":"","page":"Introducion","title":"Introducion","text":"] add https://github.com/richard-weinhold/RedundancyRemoval","category":"page"},{"location":"","page":"Introducion","title":"Introducion","text":"or from a local clone/fork of the repository via: ","category":"page"},{"location":"","page":"Introducion","title":"Introducion","text":"] add develop --local path-to-repository","category":"page"},{"location":"","page":"Introducion","title":"Introducion","text":"The recommended julia version is 1.5, although compatibility is given for version >= 1.3, but not continuously tested. ","category":"page"},{"location":"#Example","page":"Introducion","title":"Example","text":"","category":"section"},{"location":"","page":"Introducion","title":"Introducion","text":"The algorithm relies on the (N-1) PTDF, the corresponding line capacities and optionally upper/lower bounds on nodal injections as inputs. The example folder contains these files compiled for the IEEE 118 bus network and the test folder uses a small example to illustrate its functionality.","category":"page"},{"location":"","page":"Introducion","title":"Introducion","text":"The algorithm can be run for the exemplary data with the following code:","category":"page"},{"location":"","page":"Introducion","title":"Introducion","text":"  using RedundancyRemoval\n  wdir = <path to /examples>\n  file_suffix = \"ieee118\"\n  run_redundancy_removal(wdir, file_suffix)","category":"page"},{"location":"","page":"Introducion","title":"Introducion","text":"The main function runredundancyremoval can also directly take the input PTDF matrix A, line capacity vector b and the vector x_bounds as input, as shown in the test/runtests.jl.","category":"page"},{"location":"#Exposed-function-of-the-MarketModel","page":"Introducion","title":"Exposed function of the MarketModel","text":"","category":"section"},{"location":"","page":"Introducion","title":"Introducion","text":"run_redundancy_removal","category":"page"},{"location":"#RedundancyRemoval.run_redundancy_removal","page":"Introducion","title":"RedundancyRemoval.run_redundancy_removal","text":"run_redundancy_removal(\n    wdir::String, \n    file_suffix::String, \n    input_optimizer; \n    kwargs...)\n\nrun_redundancy_removal(\n    A::Array{Float64}, \n    b::Vector{Float64}, \n    x_bounds::Vector{Float64}, \n    input_optimizer;\n    filter_only::Bool=true, \n    parallel::Bool=true,\n    preprocessing::Bool=true)\n\nRuns the RedundancyRemoval on files in wdir, the files that the program is looking for are A.csv, b.csv and x_bounds.csv with suffix or directly supply the inputs Array and Vectors. \n\nSee the examples folder for exact formatting. Generally the input matrix A represents a PTDF matrix, where rows represent lines/contingencies and columns nodal power injections, vector b the line capacity for each row in the PTDF matrix and the x_bounds vector represents the symmetrical bounds for nodal injections. \n\nThe resulting vector I holds indices of rows where A[:, I] x <= b[I] is a non-redundant system of  inequalities equivalent to the full system of inequalities.  \n\nOptional arguments can be used to influence the execution of the algorithm. The algorithm can be executed using multiple threads. In that case sections of the checked indices are run in parallel to filter out redundant indices. After each pass, sections are combined and re-run. When parallel=False, the algorithm will be run single threaded, meaning all indices will be checked sequentially in a single pass. If parallel=True, segements will be filtered and then combines. If filteronly=True, the last pass will be executed single threaded, if filteronly=False the method LPTest will be executed in paralell for all remaining indices. \n\nThe resulting essential set will be saved to the wdir. \n\n\n\n\n\n","category":"function"},{"location":"","page":"Introducion","title":"Introducion","text":"run_redundancy_removal_fbmc_domain","category":"page"},{"location":"#RedundancyRemoval.run_redundancy_removal_fbmc_domain","page":"Introducion","title":"RedundancyRemoval.run_redundancy_removal_fbmc_domain","text":"run_redundancy_removal_fbmc_domain(\n    wdir::String, \n    input_optimizer; \n    parallel::Bool=false)\n\nRun the RedundancyRemoval algorithm for each timedependant system of inequalities, namely zonal day-ahead domains for commercial exchange (FBMC Domains). This function will go through each timestep and presolve the system of inequalities Ax <= b, where A is the zonal PTDF, x zonal net positions and b the remaining capacitiy on the network elements (RAM). \n\nSee the examples folder for exact formatting of the input data (Ab_info.csv). \n\nThe optional argument parallel makes the process run in parallel, generally the default setting false seems to work best, as the overhead of Threading the problem outweighs its benefits since  the systems are of low dimensionality (< 20). \n\n\n\n\n\n","category":"function"},{"location":"#Related-Publications","page":"Introducion","title":"Related Publications","text":"","category":"section"},{"location":"","page":"Introducion","title":"Introducion","text":"(preprint) Weinhold and Mieth (2020), Power Market Tool (POMATO) for the Analysis of Zonal   Electricity Markets\nWeinhold and Mieth (2020), Fast Security-Constrained Optimal Power Flow through   Low-Impact and Redundancy Screening\nSchÃ¶nheit, Weinhold, Dierstein (2020), The impact of different strategies for generation   shift keys (GSKs) on  the flow-based market coupling domain: A model-based analysis of Central Western Europe","category":"page"}]
}
